<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Test Validation Notifications</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-passed {
            border-left: 4px solid #28a745;
            background: #d4edda;
        }
        .test-failed {
            border-left: 4px solid #dc3545;
            background: #f8d7da;
        }
        .test-pending {
            border-left: 4px solid #ffc107;
            background: #fff3cd;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .success {
            background: #28a745;
        }
        .danger {
            background: #dc3545;
        }
        .warning {
            background: #ffc107;
            color: #212529;
        }
        pre {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-pass { background: #28a745; }
        .status-fail { background: #dc3545; }
        .status-pending { background: #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß™ Test de Validation - Module Notifications</h1>
        
        <div class="test-section">
            <h2>üìã Objectifs des Tests</h2>
            <ul>
                <li><strong>‚úÖ Test 1:</strong> V√©rifier qu'1 seule notification est cr√©√©e apr√®s un update</li>
                <li><strong>‚úÖ Test 2:</strong> V√©rifier que le champ link est visible dans l'espace participant</li>
                <li><strong>üîß Test 3:</strong> Tester la correction backend (upsert vs delete/recreate)</li>
                <li><strong>üßπ Test 4:</strong> Valider le nettoyage des doublons</li>
            </ul>
        </div>

        <div class="test-section">
            <h2>üéØ Tests Automatis√©s</h2>
            <button onclick="runAllTests()" class="success">üöÄ Lancer tous les tests</button>
            <button onclick="testDuplicationPrevention()">Test 1: Pr√©vention doublons</button>
            <button onclick="testLinkVisibility()">Test 2: Visibilit√© des liens</button>
            <button onclick="testBackendUpsert()">Test 3: Backend upsert</button>
            <button onclick="testCleanupFunction()">Test 4: Nettoyage</button>
        </div>

        <div id="test-results"></div>

        <div class="test-section">
            <h2>üìä Logs de Test</h2>
            <button onclick="clearLogs()" class="warning">üßπ Effacer les logs</button>
            <pre id="test-logs"></pre>
        </div>
    </div>

    <script>
        let testResults = [];

        function log(message) {
            const logs = document.getElementById('test-logs');
            const timestamp = new Date().toLocaleTimeString();
            logs.textContent += `[${timestamp}] ${message}\n`;
            console.log(message);
        }

        function clearLogs() {
            document.getElementById('test-logs').textContent = '';
        }

        function updateTestResults() {
            const resultsDiv = document.getElementById('test-results');
            let html = '<div class="test-section"><h2>üìà R√©sultats des Tests</h2>';
            
            testResults.forEach((result, index) => {
                const statusClass = result.passed ? 'test-passed' : result.failed ? 'test-failed' : 'test-pending';
                const statusIndicator = result.passed ? 'status-pass' : result.failed ? 'status-fail' : 'status-pending';
                
                html += `
                    <div class="${statusClass}" style="margin: 10px 0; padding: 15px; border-radius: 5px;">
                        <h4><span class="status-indicator ${statusIndicator}"></span>${result.name}</h4>
                        <p><strong>Status:</strong> ${result.status}</p>
                        <p><strong>D√©tails:</strong> ${result.details}</p>
                        ${result.error ? `<p><strong>Erreur:</strong> <code>${result.error}</code></p>` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }

        function addTestResult(name, passed, failed, status, details, error = null) {
            testResults.push({ name, passed, failed, status, details, error });
            updateTestResults();
        }

        async function testDuplicationPrevention() {
            log('üß™ TEST 1: Pr√©vention des doublons lors des updates');
            
            try {
                // Simuler une notification existante
                const testNotification = {
                    id: 'test-notif-1',
                    title: 'Test Notification',
                    description: 'Test description',
                    link: 'https://example.com',
                    type: 'information',
                    date: new Date().toISOString(),
                    isRead: false
                };

                // Simuler l'ajout initial
                let notifications = [testNotification];
                log(`üìä Initial: ${notifications.length} notification`);

                // Simuler un update (m√™me contenu)
                const updateNotification = {
                    ...testNotification,
                    link: 'https://updated-link.com'
                };

                // Test de la logique de pr√©vention des doublons
                const isDuplicate = notifications.some(existing => 
                    existing.id === updateNotification.id ||
                    (existing.title === updateNotification.title && 
                     existing.description === updateNotification.description)
                );

                if (isDuplicate) {
                    // Update en place
                    notifications = notifications.map(n => 
                        n.id === updateNotification.id ? updateNotification : n
                    );
                } else {
                    // Ajouter nouveau
                    notifications.push(updateNotification);
                }

                log(`üìä After update: ${notifications.length} notification(s)`);
                
                if (notifications.length === 1) {
                    addTestResult(
                        'Test 1: Pr√©vention doublons',
                        true, false,
                        'PASS√â ‚úÖ',
                        `1 seule notification apr√®s update (attendu: 1, obtenu: ${notifications.length})`
                    );
                    log('‚úÖ TEST 1 PASS√â: Aucun doublon cr√©√©');
                } else {
                    addTestResult(
                        'Test 1: Pr√©vention doublons',
                        false, true,
                        '√âCHOU√â ‚ùå',
                        `Doublons d√©tect√©s (attendu: 1, obtenu: ${notifications.length})`
                    );
                    log('‚ùå TEST 1 √âCHOU√â: Doublons cr√©√©s');
                }

            } catch (error) {
                addTestResult(
                    'Test 1: Pr√©vention doublons',
                    false, true,
                    'ERREUR ‚ùå',
                    'Erreur lors du test',
                    error.message
                );
                log(`‚ùå TEST 1 ERREUR: ${error.message}`);
            }
        }

        async function testLinkVisibility() {
            log('üß™ TEST 2: Visibilit√© du champ link dans l\'espace participant');
            
            try {
                // Simuler une notification avec lien
                const notificationWithLink = {
                    id: 'test-link-1',
                    title: 'Notification avec lien',
                    description: 'Cette notification contient un lien',
                    link: 'https://windsurf.com/editor',
                    type: 'information',
                    date: new Date().toISOString(),
                    isRead: false
                };

                // Test de la logique de rendu du lien
                const shouldShowLink = !!(notificationWithLink.link && notificationWithLink.link.trim());
                
                // Simuler le HTML qui serait g√©n√©r√©
                let linkHTML = '';
                if (shouldShowLink) {
                    linkHTML = `
                        <div class="mb-3">
                            <span class="text-sm font-medium text-blue-800">Lien:</span>
                            <a href="${notificationWithLink.link}" target="_blank" rel="noopener noreferrer">
                                <span>Acc√©der au lien</span>
                            </a>
                        </div>
                    `;
                }

                log(`üîó Link pr√©sent: ${shouldShowLink}`);
                log(`üìù HTML g√©n√©r√©: ${linkHTML.length > 0 ? 'Oui' : 'Non'}`);

                if (shouldShowLink && linkHTML.length > 0) {
                    addTestResult(
                        'Test 2: Visibilit√© des liens',
                        true, false,
                        'PASS√â ‚úÖ',
                        'Le champ link est correctement rendu dans l\'interface'
                    );
                    log('‚úÖ TEST 2 PASS√â: Lien visible dans l\'interface');
                } else {
                    addTestResult(
                        'Test 2: Visibilit√© des liens',
                        false, true,
                        '√âCHOU√â ‚ùå',
                        'Le champ link n\'est pas rendu correctement'
                    );
                    log('‚ùå TEST 2 √âCHOU√â: Lien non visible');
                }

            } catch (error) {
                addTestResult(
                    'Test 2: Visibilit√© des liens',
                    false, true,
                    'ERREUR ‚ùå',
                    'Erreur lors du test de visibilit√©',
                    error.message
                );
                log(`‚ùå TEST 2 ERREUR: ${error.message}`);
            }
        }

        async function testBackendUpsert() {
            log('üß™ TEST 3: Test de la logique backend upsert');
            
            try {
                // Simuler la logique backend corrig√©e
                const participantId = 'PART-550776';
                const existingNotifications = [
                    { _id: 'notif1', title: 'Existing', description: 'Test', link: 'old-link.com' }
                ];
                
                const updateNotifications = [
                    { id: 'notif1', title: 'Existing', description: 'Test', link: 'new-link.com' }, // Update
                    { title: 'New', description: 'New notification', link: 'brand-new-link.com' } // Create
                ];

                // Simuler la logique upsert
                const existingIds = new Set(existingNotifications.map(n => n._id));
                let operations = { updates: 0, creates: 0, deletes: 0 };

                for (const notification of updateNotifications) {
                    if (notification.id && existingIds.has(notification.id)) {
                        // UPDATE
                        operations.updates++;
                        log(`üîÑ UPDATE: ${notification.id}`);
                        existingIds.delete(notification.id);
                    } else {
                        // CREATE
                        operations.creates++;
                        log(`‚ûï CREATE: ${notification.title}`);
                    }
                }

                // DELETE orphaned
                operations.deletes = existingIds.size;
                if (operations.deletes > 0) {
                    log(`üóëÔ∏è DELETE: ${operations.deletes} orphaned notifications`);
                }

                log(`üìä Operations: ${operations.updates} updates, ${operations.creates} creates, ${operations.deletes} deletes`);

                // Validation: doit avoir 1 update, 1 create, 0 delete
                const expectedOps = { updates: 1, creates: 1, deletes: 0 };
                const opsMatch = Object.keys(expectedOps).every(key => operations[key] === expectedOps[key]);

                if (opsMatch) {
                    addTestResult(
                        'Test 3: Backend upsert',
                        true, false,
                        'PASS√â ‚úÖ',
                        `Op√©rations correctes: ${operations.updates} updates, ${operations.creates} creates, ${operations.deletes} deletes`
                    );
                    log('‚úÖ TEST 3 PASS√â: Logique upsert correcte');
                } else {
                    addTestResult(
                        'Test 3: Backend upsert',
                        false, true,
                        '√âCHOU√â ‚ùå',
                        `Op√©rations incorrectes: attendu ${JSON.stringify(expectedOps)}, obtenu ${JSON.stringify(operations)}`
                    );
                    log('‚ùå TEST 3 √âCHOU√â: Logique upsert incorrecte');
                }

            } catch (error) {
                addTestResult(
                    'Test 3: Backend upsert',
                    false, true,
                    'ERREUR ‚ùå',
                    'Erreur lors du test backend',
                    error.message
                );
                log(`‚ùå TEST 3 ERREUR: ${error.message}`);
            }
        }

        async function testCleanupFunction() {
            log('üß™ TEST 4: Test de la fonction de nettoyage des doublons');
            
            try {
                // Cr√©er des notifications avec doublons
                const notificationsWithDuplicates = [
                    { id: '1', title: 'Test', description: 'Desc', link: '', date: '2023-01-01' },
                    { id: '2', title: 'Test', description: 'Desc', link: 'https://link.com', date: '2023-01-02' }, // Doublon avec lien
                    { id: '3', title: 'Unique', description: 'Unique desc', link: '', date: '2023-01-03' },
                    { id: '4', title: 'Test', description: 'Desc', link: '', date: '2023-01-01' } // Doublon sans lien
                ];

                log(`üìä Avant nettoyage: ${notificationsWithDuplicates.length} notifications`);

                // Simuler la fonction de nettoyage
                const groups = {};
                notificationsWithDuplicates.forEach(notif => {
                    const key = `${notif.title}-${notif.description}`;
                    if (!groups[key]) groups[key] = [];
                    groups[key].push(notif);
                });

                const cleaned = Object.values(groups).map(group => {
                    if (group.length === 1) return group[0];
                    
                    // Prioriser: avec lien > plus r√©cent
                    return group.sort((a, b) => {
                        const aHasLink = !!(a.link && a.link.trim());
                        const bHasLink = !!(b.link && b.link.trim());
                        
                        if (aHasLink && !bHasLink) return -1;
                        if (!aHasLink && bHasLink) return 1;
                        
                        return new Date(b.date) - new Date(a.date);
                    })[0];
                });

                log(`üìä Apr√®s nettoyage: ${cleaned.length} notifications`);
                log(`üßπ Doublons supprim√©s: ${notificationsWithDuplicates.length - cleaned.length}`);

                // V√©rifier que le doublon gard√© est celui avec le lien
                const testGroup = cleaned.find(n => n.title === 'Test');
                const hasCorrectLink = testGroup && testGroup.link === 'https://link.com';

                if (cleaned.length === 2 && hasCorrectLink) {
                    addTestResult(
                        'Test 4: Nettoyage doublons',
                        true, false,
                        'PASS√â ‚úÖ',
                        `Nettoyage correct: ${notificationsWithDuplicates.length} ‚Üí ${cleaned.length} notifications, doublon avec lien conserv√©`
                    );
                    log('‚úÖ TEST 4 PASS√â: Nettoyage des doublons efficace');
                } else {
                    addTestResult(
                        'Test 4: Nettoyage doublons',
                        false, true,
                        '√âCHOU√â ‚ùå',
                        `Nettoyage incorrect: ${cleaned.length} notifications finales, lien correct: ${hasCorrectLink}`
                    );
                    log('‚ùå TEST 4 √âCHOU√â: Nettoyage inefficace');
                }

            } catch (error) {
                addTestResult(
                    'Test 4: Nettoyage doublons',
                    false, true,
                    'ERREUR ‚ùå',
                    'Erreur lors du test de nettoyage',
                    error.message
                );
                log(`‚ùå TEST 4 ERREUR: ${error.message}`);
            }
        }

        async function runAllTests() {
            log('üöÄ LANCEMENT DE TOUS LES TESTS');
            testResults = []; // Reset
            
            await testDuplicationPrevention();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testLinkVisibility();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testBackendUpsert();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testCleanupFunction();
            
            // R√©sum√© final
            const passed = testResults.filter(r => r.passed).length;
            const total = testResults.length;
            
            log(`\nüìä R√âSUM√â FINAL: ${passed}/${total} tests pass√©s`);
            
            if (passed === total) {
                log('üéâ TOUS LES TESTS SONT PASS√âS! Le module notifications est corrig√©.');
            } else {
                log(`‚ö†Ô∏è ${total - passed} test(s) ont √©chou√©. Corrections n√©cessaires.`);
            }
        }

        // Auto-run au chargement
        window.onload = () => {
            log('üß™ Script de test des notifications charg√©');
            log('üëÜ Cliquez sur "Lancer tous les tests" pour commencer');
        };
    </script>
</body>
</html>
